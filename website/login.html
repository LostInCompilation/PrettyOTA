<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="A better looking OTA web updater for embedded devices." />
    <meta name="author" content="Marc SchÃ¶ndorf">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg fill='%234063ff' width='250px' height='250px' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M6 3h8a3 3 0 0 1 3 3v8a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3zm0 2a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H6zm2 2h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v2h2V9H9zM6 0a1 1 0 0 1 1 1v2a1 1 0 1 1-2 0V1a1 1 0 0 1 1-1zM1 5h2a1 1 0 1 1 0 2H1a1 1 0 1 1 0-2zm16 0h2a1 1 0 0 1 0 2h-2a1 1 0 0 1 0-2zM1 9h2a1 1 0 1 1 0 2H1a1 1 0 0 1 0-2zm16 0h2a1 1 0 0 1 0 2h-2a1 1 0 0 1 0-2zM1 13h2a1 1 0 0 1 0 2H1a1 1 0 0 1 0-2zm16 0h2a1 1 0 0 1 0 2h-2a1 1 0 0 1 0-2zM6 16a1 1 0 0 1 1 1v2a1 1 0 0 1-2 0v-2a1 1 0 0 1 1-1zm8-16a1 1 0 0 1 1 1v2a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1zm0 16a1 1 0 0 1 1 1v2a1 1 0 0 1-2 0v-2a1 1 0 0 1 1-1zM10 0a1 1 0 0 1 1 1v2a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1zm0 16a1 1 0 0 1 1 1v2a1 1 0 0 1-2 0v-2a1 1 0 0 1 1-1z'/%3E%3C/svg%3E" />
    <title>PrettyOTA Login</title>
    <script type="module" crossorigin>
        // *********************************************************************
        // MD5 hash calculation
        const md5 = (function() {
            function MD5(d){return M(V(Y(X(d),8*d.length)))}
            function M(d){for(var _,m='0123456789abcdef',f='',r=0;r<d.length;r++){_=d.charCodeAt(r);f+=m.charAt(_>>>4&15)+m.charAt(15&_)}return f}
            function X(d){for(var _=Array(d.length>>2),m=0;m<_.length;m++){_[m]=0}for(m=0;m<8*d.length;m+=8){_[m>>5]|=(255&d.charCodeAt(m/8))<<m%32}return _}
            function V(d){for(var _='',m=0;m<32*d.length;m+=8)_+=String.fromCharCode(d[m>>5]>>>m%32&255);return _}
            function Y(d,_){
                d[_>>5]|=128<<_%32;d[14+(_+64>>>9<<4)]=_;
                for(var m=1732584193,f=-271733879,r=-1732584194,i=271733878,n=0;n<d.length;n+=16){
                var h=m,t=f,g=r,e=i;
                f=md5ii(f=md5ii(f=md5ii(f=md5ii(f=md5hh(f=md5hh(f=md5hh(f=md5hh(f=md5gg(f=md5gg(f=md5gg(f=md5gg(f=md5ff(f=md5ff(f=md5ff(f=md5ff(f,r=md5ff(r,i=md5ff(i,m=md5ff(m,f,r,i,d[n+0],7,-680876936),f,r,d[n+1],12,-389564586),m,f,d[n+2],17,606105819),i,m,d[n+3],22,-1044525330),r=md5ff(r,i=md5ff(i,m=md5ff(m,f,r,i,d[n+4],7,-176418897),f,r,d[n+5],12,1200080426),m,f,d[n+6],17,-1473231341),i,m,d[n+7],22,-45705983),r=md5ff(r,i=md5ff(i,m=md5ff(m,f,r,i,d[n+8],7,1770035416),f,r,d[n+9],12,-1958414417),m,f,d[n+10],17,-42063),i,m,d[n+11],22,-1990404162),r=md5ff(r,i=md5ff(i,m=md5ff(m,f,r,i,d[n+12],7,1804603682),f,r,d[n+13],12,-40341101),m,f,d[n+14],17,-1502002290),i,m,d[n+15],22,1236535329),r=md5gg(r,i=md5gg(i,m=md5gg(m,f,r,i,d[n+1],5,-165796510),f,r,d[n+6],9,-1069501632),m,f,d[n+11],14,643717713),i,m,d[n+0],20,-373897302),r=md5gg(r,i=md5gg(i,m=md5gg(m,f,r,i,d[n+5],5,-701558691),f,r,d[n+10],9,38016083),m,f,d[n+15],14,-660478335),i,m,d[n+4],20,-405537848),r=md5gg(r,i=md5gg(i,m=md5gg(m,f,r,i,d[n+9],5,568446438),f,r,d[n+14],9,-1019803690),m,f,d[n+3],14,-187363961),i,m,d[n+8],20,1163531501),r=md5gg(r,i=md5gg(i,m=md5gg(m,f,r,i,d[n+13],5,-1444681467),f,r,d[n+2],9,-51403784),m,f,d[n+7],14,1735328473),i,m,d[n+12],20,-1926607734),r=md5hh(r,i=md5hh(i,m=md5hh(m,f,r,i,d[n+5],4,-378558),f,r,d[n+8],11,-2022574463),m,f,d[n+11],16,1839030562),i,m,d[n+14],23,-35309556),r=md5hh(r,i=md5hh(i,m=md5hh(m,f,r,i,d[n+1],4,-1530992060),f,r,d[n+4],11,1272893353),m,f,d[n+7],16,-155497632),i,m,d[n+10],23,-1094730640),r=md5hh(r,i=md5hh(i,m=md5hh(m,f,r,i,d[n+13],4,681279174),f,r,d[n+0],11,-358537222),m,f,d[n+3],16,-722521979),i,m,d[n+6],23,76029189),r=md5hh(r,i=md5hh(i,m=md5hh(m,f,r,i,d[n+9],4,-640364487),f,r,d[n+12],11,-421815835),m,f,d[n+15],16,530742520),i,m,d[n+2],23,-995338651),r=md5ii(r,i=md5ii(i,m=md5ii(m,f,r,i,d[n+0],6,-198630844),f,r,d[n+7],10,1126891415),m,f,d[n+14],15,-1416354905),i,m,d[n+5],21,-57434055),r=md5ii(r,i=md5ii(i,m=md5ii(m,f,r,i,d[n+12],6,1700485571),f,r,d[n+3],10,-1894986606),m,f,d[n+10],15,-1051523),i,m,d[n+1],21,-2054922799),r=md5ii(r,i=md5ii(i,m=md5ii(m,f,r,i,d[n+8],6,1873313359),f,r,d[n+15],10,-30611744),m,f,d[n+6],15,-1560198380),i,m,d[n+13],21,1309151649),r=md5ii(r,i=md5ii(i,m=md5ii(m,f,r,i,d[n+4],6,-145523070),f,r,d[n+11],10,-1120210379),m,f,d[n+2],15,718787259),i,m,d[n+9],21,-343485551);
                m=safeadd(m,h);f=safeadd(f,t);r=safeadd(r,g);i=safeadd(i,e);
                }
                return[m,f,r,i];
            }
            function md5cmn(d,_,m,f,r,i){return safeadd(bitrol(safeadd(safeadd(_,d),safeadd(f,i)),r),m)}
            function md5ff(d,_,m,f,r,i,n){return md5cmn(_&m|~_&f,d,_,r,i,n)}
            function md5gg(d,_,m,f,r,i,n){return md5cmn(_&f|m&~f,d,_,r,i,n)}
            function md5hh(d,_,m,f,r,i,n){return md5cmn(_^m^f,d,_,r,i,n)}
            function md5ii(d,_,m,f,r,i,n){return md5cmn(m^(_|~f),d,_,r,i,n)}
            function safeadd(d,_){var m=(65535&d)+(65535&_);return(d>>16)+(_>>16)+(m>>16)<<16|65535&m}
            function bitrol(d,_){return d<<_|d>>>32-_}
            function MD5Unicode(buffer){
                if(!(buffer instanceof Uint8Array)){
                buffer=new TextEncoder().encode(typeof buffer==='string'?buffer:JSON.stringify(buffer));
                }
                var binary=[],bytes=new Uint8Array(buffer);
                for(var i=0,il=bytes.byteLength;i<il;i++){
                binary.push(String.fromCharCode(bytes[i]));
                }
                return MD5(binary.join(''));
            }
            return MD5Unicode;
        })();

        // *********************************************************************
        // Login form
        let loginAttemptRunning = false;
        document.getElementById("loginForm").addEventListener("submit", async function (e) {
            loginAttemptRunning = true;

            e.preventDefault();

            const loginBtn = document.getElementById("loginButton");
            const username = document.getElementById("username");
            const password = document.getElementById("password");
            const loaderContainer = document.getElementById("loader-container");
            const loaderBar = document.getElementById("loader-bar");

            // Disable login button and show loader
            loginBtn.disabled = true;
            loaderContainer.style.visibility = "visible";
            loaderBar.classList.add("animate");

            try {
                // Set up request timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 4000);

                // Send request
                const response = await fetch(localStorage.getItem("login_url"), {
                    method: "POST",
                    headers: {"Content-Type": "application/json; charset=UTF-8"},
                    body: JSON.stringify({
                        userId: username.value,
                        password: md5(password.value)
                    }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                // Keep the normal loader animation running for (at least) 700ms
                await new Promise(resolve => setTimeout(resolve, 700));

                // Was login successful?
                if (response.ok) {
                    // Hide notification
                    hideNotification();

                    // Switch loader to success state
                    const currentLeft = window.getComputedStyle(loaderBar).getPropertyValue("left");
                    loaderBar.classList.remove("animate");
                    loaderBar.style.left = currentLeft;
                    loaderBar.classList.add("completed");
                    loaderBar.style.transform = "scaleX(4)";

                    // Keep showing success loader bar for a short time
                    await new Promise(resolve => setTimeout(resolve, 400));

                    // Fade out page
                    document.querySelector(".card").classList.add("disappear");
                    document.getElementById("fadeOverlay").classList.add("fade-to-black");

                    // Delay redirect to allow disapper animation to complete
                    await new Promise(resolve => setTimeout(resolve, 800));

                    // Redirect to main URL
                    window.location.replace(localStorage.getItem("main_url"));

                    return;
                }
                else {
                    // Log in failed
                    const errorText = await response.text();

                    if (response.status === 401) {
                        // Wrong credentials
                        showNotification("Log in failed", errorText, 7000);

                        // Trigger shake animation for lock
                        document.getElementById("lockGroup").classList.add("shake");
                        setTimeout(() => document.getElementById("lockGroup").classList.remove("shake"), 350);

                        // Red border on input fields
                        username.classList.add("wrong-credential");
                        password.classList.add("wrong-credential");
                    }
                    else {
                        // Other error
                        showNotification("Log in failed", `Server response: ${response.status} - ${response.statusText}`, 7000);
                    }
                }
            }
            catch (error) {
                if (error.name === "AbortError")
                    showNotification("Request Timeout", "The server took too long to respond. Please try again.", 7000);
                else
                    showNotification("Log in failed", "Network or server error", 7000);
            }

            // Enable login button
            loginBtn.disabled = false;

            // Hide loader
            loaderContainer.style.visibility = "hidden";
            loaderBar.classList.remove("animate");

            loginAttemptRunning = false;
        });

        // Add event listeners to remove red border around input fields on focus
        document.getElementById("username").addEventListener("focus", function() {this.classList.remove("wrong-credential");});
        document.getElementById("password").addEventListener("focus", function() {this.classList.remove("wrong-credential");});

        // *********************************************************************
        // Connection status indicator
        let connectionIndicatorStatus = false;
        function updateConnectionStatusIndicator(connected) {
            // Only update if status has changed
            if (connected === connectionIndicatorStatus)
                return;

            connectionIndicatorStatus = connected;

            // Update status indicator
            document.getElementById("connectionIndicator").classList.remove("connected", "disconnected");
            document.getElementById("connectionIndicator").classList.add(connected ? "connected" : "disconnected");

            // Update text and tooltip
            if (connected) {
                document.getElementById("connectionIndicatorText").textContent = "Connected";
                document.getElementById("connectionIndicatorTooltip").textContent = "Connected to server";
            }
            else {
                document.getElementById("connectionIndicatorText").textContent = "Offline";
                document.getElementById("connectionIndicatorTooltip").textContent = "Could not connect to server";
            }
        }

        // Show/hide tooltip on hover
        document.getElementById("connectionIndicator").addEventListener("mouseenter", () => {
            document.getElementById("connectionIndicatorTooltip").classList.add("visible");
        });
        document.getElementById("connectionIndicator").addEventListener("mouseleave", () => {
            document.getElementById("connectionIndicatorTooltip").classList.remove("visible");
        });

        // *********************************************************************
        // Notification popup
        let notificationTimeout = null;
        function showNotification(title, message, timeoutMs = 7000) {
            // Update content
            document.getElementById("notificationTitle").textContent = title;
            document.getElementById("notificationMessage").textContent = message;

            // Clear existing timeout if notification is already visible
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
                notificationTimeout = null;
            }

            // Show notification
            document.getElementById("notification").classList.add("show");

            // Set new timeout for auto-hide
            if (timeoutMs > 0) {
                notificationTimeout = setTimeout(() => {
                    hideNotification();
                }, timeoutMs);
            }
        }

        function hideNotification() {
            // Clear timeout if it exists
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
                notificationTimeout = null;
            }

            // Hide notification
            document.getElementById("notification").classList.remove("show");
        }

        // Attach click event to notification close button
        document.getElementById("notificationCloseButton").addEventListener("click", hideNotification);

        // *********************************************************************
        // General functions
        // Query PrettyOTA info
        let queryPrettyOTAInfoSucceeded = false;
        async function queryPrettyOTAInfo(maxRetries = 5, delayMs = 1000, timeoutMs = 4000) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

                    const response = await fetch("/prettyota/queryPrettyOTAInfo", {signal: controller.signal});
                    clearTimeout(timeoutId);

                    if (!response.ok)
                        throw new Error(`Could not get PrettyOTA info. Status: ${response.status} ${response.statusText}`);

                    const jsonObj = await response.json();

                    // Validate response structure
                    if (!jsonObj?.prettyotaVersion || !jsonObj?.mainURL || !jsonObj?.loginURL)
                        throw new Error("Invalid JSON structure from PrettyOTA info query.");

                    localStorage.setItem("version_string", jsonObj.prettyotaVersion);
                    localStorage.setItem("main_url", jsonObj.mainURL);
                    localStorage.setItem("login_url", jsonObj.loginURL);

                    queryPrettyOTAInfoSucceeded = true;

                    return;
                }
                catch (error) {
                    console.warn(error.message);

                    if (attempt >= maxRetries) {
                        console.error("All retry attempts to get PrettyOTA info failed.");
                        showNotification("Connection or server issue", "There seems to be an issue with the connection to the server. Please try again and refresh the page.", 0);

                        return;
                    }

                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
            }
        }

        // Check server connection periodically
        async function runConnectionMonitoring(intervalMs = 2000, timeoutMs = 4000) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

                const response = await fetch("/prettyota/rebootCheck", {
                    method: "GET",
                    signal: controller.signal,
                    cache: "no-store"
                });

                clearTimeout(timeoutId);
                updateConnectionStatusIndicator(response.ok);

                // Only update the disabled state if a login attempt is not running
                if (!loginAttemptRunning)
                    document.getElementById("loginButton").disabled = !queryPrettyOTAInfoSucceeded || !response.ok;
            }
            catch (error) {
                updateConnectionStatusIndicator(false);

                // Disable login button
                document.getElementById("loginButton").disabled = true;
            }
            finally {
                // Schedule the next check 2 seconds after this one completes
                setTimeout(runConnectionMonitoring, intervalMs);
            }
        }

        // On page load
        function onLoad() {
            // Set default values if not set
            if (!("version_string" in localStorage))
                localStorage.setItem("version_string", "1.0.0");
            if (!("main_url" in localStorage))
                localStorage.setItem("main_url", "/update");
            if (!("login_url" in localStorage))
                localStorage.setItem("login_url", "/login");

            // Setup background rendering
            setupBackgroundRendering();

            // Query PrettyOTA info
            queryPrettyOTAInfo();

            // Set initial connection status and start periodic connection checks after 2 seconds
            // This is to wait for getting the PrettyOTA info
            updateConnectionStatusIndicator(true);
            setTimeout(() => {
                runConnectionMonitoring();
            }, 2000);
        }

        // Add event listener for page load
        window.addEventListener("load", onLoad);

        // *********************************************************************
        // Background rendering
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const frameInterval = 1000 / 60; // 60 FPS (fixed frame rate)
        let lastFrameTime = 0;
        let nodes = [];

        function lerp(x1, y1, x2, y2, x) {
            return Math.floor(y1 + ((x - x1) * (y2 - y1)) / (x2 - x1));
        }

        function calculateMaxDistance(width, height) {
            const area = width * height;
            return area < 250000 ? 80 :
                    area < 1000000 ? lerp(250000, 80, 1000000, 180, area) :
                    area < 10000000 ? lerp(1000000, 180, 2000000, 210, area) :
                    210;
        }

        function calculateNodeDensity(width, height) {
            const area = width * height;
            return area < 750000 ? 60 :
                    area < 1500000 ? lerp(750000, 60, 1500000, 110, area) :
                    area < 5000000 ? lerp(1500000, 110, 5000000, 200, area) :
                    200;
        }

        // Node class
        class Node {
            constructor(width, height) {
                const marginX = width * 0.06;
                const marginY = height * 0.03;

                // Position
                this.x = (Math.random() * (width - 2 * marginX)) + marginX;
                this.y = (Math.random() * (height - 2 * marginY)) + marginY;

                // Scale velocity based on canvas size for consistent animation speed
                const speedFactor = Math.sqrt((width * height) / 2e6) * 0.3;
                this.vx = (Math.random() - 0.5) * speedFactor;
                this.vy = (Math.random() - 0.5) * speedFactor;

                this.cluster = Math.floor(Math.random() * 3);
            }

            update(width, height) {
                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Bounce off edges
                if (this.x < 20 || this.x > width - 20) {
                    this.vx *= -1;
                    this.vx += (Math.random() - 0.5) * 0.07;
                    this.vx = Math.min(Math.max(this.vx, -0.1), 0.1);
                }
                if (this.y < 20 || this.y > height - 20) {
                    this.vy *= -1;
                    this.vy += (Math.random() - 0.5) * 0.07;
                    this.vy = Math.min(Math.max(this.vy, -0.1), 0.1);
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(170, 190, 255, 0.75)";
                ctx.fill();
            }
        }

        // Resize canvas and adjust node count
        function resizeCanvas() {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            nodes.forEach(node => {
                // Scale positions relative to new dimensions
                if (oldWidth > 0 && oldHeight > 0) {
                    node.x = (node.x / oldWidth) * canvas.width;
                    node.y = (node.y / oldHeight) * canvas.height;

                    // Also scale velocity to maintain relative speed
                    const velocityScale = Math.sqrt((canvas.width * canvas.height) / (oldWidth * oldHeight));
                    node.vx *= velocityScale;
                    node.vy *= velocityScale;
                }
            });

            // Update node count (remove and add nodes as needed)
            const idealNodeCount = calculateNodeDensity(canvas.width, canvas.height);
            nodes = Array.from({ length: idealNodeCount }, (_, i) => i < nodes.length ? nodes[i] : new Node(canvas.width, canvas.height));
        }

        // Animation loop
        function animate(time) {
            requestAnimationFrame(animate);

            if (time - lastFrameTime >= frameInterval) {
                lastFrameTime = time;

                // Clear screen
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw nodes (with glow using shadow)
                ctx.shadowBlur = 7;
                ctx.shadowColor = "rgba(255, 255, 255, 1.0)";
                nodes.forEach(node => {
                    node.update(canvas.width, canvas.height);
                    node.draw();
                });
                ctx.shadowBlur = 0;

                // Draw edges (lines)
                const baseMaxDist = calculateMaxDistance(canvas.width, canvas.height);
                const clusterMaxDistSq = baseMaxDist * baseMaxDist;
                const regularMaxDistSq = (baseMaxDist * 1.2) * (baseMaxDist * 1.2);

                ctx.lineWidth = 0.9;
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[i].x - nodes[j].x;
                        const dy = nodes[i].y - nodes[j].y;
                        const distanceSquared = dx * dx + dy * dy;
                        const maxDistanceSquared = (nodes[i].cluster === nodes[j].cluster) ? clusterMaxDistSq : regularMaxDistSq;

                        // Only consider connections within maximum distance
                        if (distanceSquared < maxDistanceSquared) {
                            // Calculate opacity based on distance
                            const opacity = Math.sqrt(1 - (distanceSquared / maxDistanceSquared));

                            ctx.strokeStyle = nodes[i].cluster === nodes[j].cluster
                                ? `rgba(170, 190, 255, ${opacity * 0.3})`
                                : `rgba(120, 190, 255, ${opacity * 0.15})`;

                            // Render lines
                            ctx.beginPath();
                            ctx.moveTo(nodes[i].x, nodes[i].y);
                            ctx.lineTo(nodes[j].x, nodes[j].y);
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        // Setup background rendering
        function setupBackgroundRendering() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Create nodes
            const nodeCount = calculateNodeDensity(canvas.width, canvas.height);
            nodes = Array(nodeCount).fill().map(() => new Node(canvas.width, canvas.height));

            // Start animation loop
            requestAnimationFrame(animate);
        }

        // Add resize event
        window.addEventListener("resize", resizeCanvas);
    </script>
    <style>
        * {
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        body {
            background: radial-gradient(circle at center, hsl(224, 57%, 9%), #000);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            position: absolute;
            inset: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* Helper classes */
        .no-select {
            user-select: none;
            -webkit-user-select: none;
        }

        /* Fade overlay (fade to black) */
        #fadeOverlay {
            position: fixed;
            inset: 0;
            background: black;
            opacity: 0;
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.6s ease;
        }
        #fadeOverlay.fade-to-black {
            opacity: 1;
        }

        /* Card */
        .card {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 390px;
            min-width: 330px;
            padding: 30px 33px 25px;
            margin: 20px;
            gap: 20px;
            background-color: #141414a6;
            border: 1px solid #282828;
            border-radius: 20px;
            box-shadow: 0 8px 32px #0000004d;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 1;
            animation: fadeInZoomIn 0.5s cubic-bezier(0.3, 0.7, 0.4, 1) forwards;
        }
        .card.disappear {
            animation: cardDisappear 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }
        .card-footer {
            display: flex;
            justify-content: center;
            font-size: 13px;
            color: #6f7073;
            cursor: default;
        }

        /* Connection status indicator */
        .connection-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 7px;
            padding: 4px 8px;
            font-size: 12px;
            color: #dfdfdf;
            background-color: #202020;
            border: 1px solid #383838;
            border-radius: 12px;
            transition: opacity 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
            opacity: 0.8;
            cursor: default;
        }
        .connection-indicator:hover {
            opacity: 1;
        }
        .connection-indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        .connection-indicator.connected {
            border-color: rgba(63, 194, 68, 0.4);
        }
        .connection-indicator.connected .connection-indicator-dot {
            background-color: #4CAF50;
            box-shadow: 0 0 6px #4CAF50;
        }
        .connection-indicator.disconnected {
            border-color: rgba(244, 67, 54, 0.4);
        }
        .connection-indicator.disconnected .connection-indicator-dot {
            background-color: #F44336;
            box-shadow: 0 0 6px #F44336;
        }

        /* Tooltip */
        .connection-indicator-tooltip {
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            z-index: 10;
            padding: 6px 12px;
            font-size: 12px;
            color: #ffffff;
            background: #202020;
            border: 1px solid #383838;
            border-radius: 8px;
            box-shadow: 0 4px 12px #00000033;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transform: translateX(-50%) translateY(8px) scale(0.95);
            transform-origin: top center;
            transition:
                opacity 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                box-shadow 0.3s ease;
        }
        .connection-indicator-tooltip.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
            transition:
                opacity 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                box-shadow 0.3s ease;
        }
        .connection-indicator-tooltip::before,
        .connection-indicator-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
        }
        .connection-indicator-tooltip::before {
            border: 7px solid transparent;
            border-bottom-color: #383838;
            margin-left: -7px;
        }
        .connection-indicator-tooltip::after {
            border: 6px solid transparent;
            border-bottom-color: #202020;
            margin-left: -6px;
            margin-bottom: -1px;
        }

        /* Lock icon */
        .icon-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 84px;
            height: 105px;
            margin-bottom: 20px;
            animation: fadeInZoomIn 1.2s ease-in-out forwards;
            will-change: stroke-dashoffset, opacity, transform;
        }
        .icon-container svg {
            width: 100%;
            height: 100%;
            overflow: visible;
        }
        .icon-text {
            font-size: 2.8rem;
            font-weight: 600;
            fill: white;
            text-anchor: middle;
            cursor: default;
            animation: slideUp 1.2s ease-in-out forwards;
        }
        .lock-path {
            fill: none;
            stroke-width: 6.5;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 150;
            stroke-dashoffset: 150;
            opacity: 0;
            animation: fadeIn 0.7s ease-in-out 0.0s forwards,
                       drawPath 2.8s cubic-bezier(0.2, 0.8, 0.2, 0.94) 0.1s forwards;
        }
        .lock-path:nth-child(2) {
            stroke-dasharray: 220;
            stroke-dashoffset: 220;
        }
        #lockGroup.shake {
            animation: shake 0.35s ease-in-out;
            transform-origin: center;
        }

        /* Form */
        .login-form {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        .form-group {
            position: relative;
            display: flex;
            flex-direction: column;
            width: 100%;
            margin-bottom: 20px;
        }
        .form-label {
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #9fa0a2;
        }
        .form-input {
            width: 100%;
            padding: 14px 16px 14px 44px;
            font-size: 16px;
            color: white;
            background: #141414cc;
            border: 1px solid #2b2b2b;
            border-radius: 12px;
            outline: none;
            transition: all 0.3s ease;
        }
        .form-input:focus {
            border-color: #409cffcc;
            box-shadow: 0 0 0 2px #409cff40;
            background: #232323cc;
        }
        .form-input.wrong-credential {
            border-color: #DC143C;
        }

        /* Input icons */
        .input-icon {
            position: absolute;
            color: #6f7073;
            pointer-events: none;
            transition: color 0.3s ease;
        }
        .input-icon.username {
            left: 12px;
            top: 37px;
            width: 24px;
            height: 24px;
        }
        .input-icon.password {
            left: 15px;
            top: 39px;
            width: 20px;
            height: 20px;
        }
        .form-input:focus ~ .input-icon {
            color: #409cff;
        }

        /* Login button */
        .login-button {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
            padding: 14px;
            margin-top: 12px;
            font-size: 16px;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, hsla(211, 100%, 63%, 0.9), hsla(244, 100%, 67%, 0.9));
            border: none;
            border-radius: 12px;
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.3s ease;
        }
        .login-button::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -10;
            background: linear-gradient(135deg, hsl(207, 100%, 64%), hsl(244, 100%, 70%));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .login-button:hover {
            transform: scale(1.01);
            box-shadow: 0 0 20px #409cff66;
        }
        .login-button:hover::before {
            opacity: 1;
        }
        .login-button:active {
            transform: scale(1);
        }
        .login-button:active::before {
            opacity: 0;
        }
        .login-button:disabled {
            background: linear-gradient(135deg, hsla(0, 0%, 50%, 0.4), hsla(0, 0%, 40%, 0.4));
            color: #a0a0a0;
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .login-button:disabled:hover::before {
            opacity: 0;
        }

        /* Loader */
        .loader-container {
            position: relative;
            height: 4px;
            width: 100%;
            margin-top: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
            display: block;
            visibility: hidden;
            overflow: hidden;
        }
        .loader-bar {
            position: absolute;
            top: 0;
            left: -30%;
            height: 100%;
            width: 30%;
            background: linear-gradient(90deg, rgba(64, 156, 255, 0.7), rgba(98, 87, 255, 0.7));
            border-radius: 2px;
            transition: all 0.5s ease;
        }
        .loader-bar.animate {
            animation: loading 2s infinite;
        }
        .loader-bar.completed {
            width: 100%;
            background: linear-gradient(90deg, rgba(72, 187, 120, 0.7), rgba(72, 187, 120, 0.9));
        }

        /* Notification */
        .notification {
            position: fixed;
            top: -180px;
            left: 50%;
            z-index: 10;
            display: flex;
            align-items: center;
            min-width: 390px;
            max-width: min(90vw, 480px);
            color: #f5f5f5;
            background: #202020d9;
            border: 1px solid #333333;
            border-left: 4px solid #e57373;
            border-radius: 14px;
            box-shadow: 0 10px 30px #00000066, 0 0 0 1px #ffffff14 inset;
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            opacity: 0;
            overflow: hidden;
            transform: translateX(-50%);
            transition: top 0.5s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
        }
        .notification.show {
            top: 20px;
            opacity: 1;
        }
        .notification-main-area {
            display: flex;
            align-items: center;
            padding: 12px 10px;
            flex-grow: 1;
            gap: 14px;
        }
        .notification-icon-area {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            flex-shrink: 0;
        }
        .notification-icon-area svg {
            width: 100%;
            height: 100%;
        }
        .notification-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            gap: 2px;
            padding-right: 10px;
            letter-spacing: 0.02em;
            overflow-wrap: break-word;
        }
        .notification-title {
            font-size: 1rem;
            font-weight: 700;
            line-height: 1.3;
            color: #ffffff;
        }
        .notification-message {
            font-size: 0.875rem;
            line-height: 1.5;
            color: #dcdcdc;
        }
        .notification-separator {
            width: 1px;
            background-color: #383838;
            align-self: stretch;
        }
        .notification-ok-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 65px;
            padding: 15px 10px;
            font-size: 0.875rem;
            font-weight: 600;
            color: #c0c0c0;
            background-color: transparent;
            border: none;
            outline: none;
            cursor: pointer;
            flex-shrink: 0;
            align-self: stretch;
            transition: background-color 0.25s ease, color 0.25s ease;
        }
        .notification-ok-button:hover {
            background-color: #333333;
            color: #ffffff;
        }
        .notification-ok-button:active {
            background-color: #404040;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes fadeInZoomIn {
            from { opacity: 0; transform: scale(.9); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes drawPath {
            to { stroke-dashoffset: 0; }
        }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(40px); }
            to { opacity: 1; transform: translateY(20px); }
        }
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            50% { transform: translateX(8px); }
            75% { transform: translateX(-8px); }
            100% { transform: translateX(0); }
        }
        @keyframes loading {
            from { left: -30%; }
            to { left: 100%; }
        }
        @keyframes cardDisappear {
            from { opacity: 1; transform: scale(1); filter: blur(0); }
            to { opacity: 0; transform: scale(0.96); filter: blur(10px); }
        }
    </style>
</head>
<body>
    <!-- Background -->
    <canvas id="canvas"></canvas>

    <!-- Fade overlay -->
    <div id="fadeOverlay"></div>

    <!-- Card -->
    <div class="card">
        <!-- Connection status indicator -->
        <div id="connectionIndicator" class="connection-indicator no-select">
            <span class="connection-indicator-dot"></span>
            <span id="connectionIndicatorText"></span>
            <span id="connectionIndicatorTooltip" class="connection-indicator-tooltip"></span>
        </div>

        <!-- Lock icon -->
        <div class="icon-container">
            <svg viewBox="0 0 100 190">
                <g id="lockGroup">
                    <path class="lock-path" stroke="url(#lockGradient)" d="M30 75V55a20 20 0 0140 0v20" />
                    <path class="lock-path" stroke="url(#lockGradient)" d="M30 75h40a10 10 0 0110 10v25a10 10 0 01-10 10H30a10 10 0 01-10-10V85a10 10 0 0110-10z" />
                </g>
                <text class="icon-text no-select" x="50" y="185">Authenticate</text>
                <defs>
                    <lineargradient id="lockGradient" x1="20" y1="30" x2="80" y2="55" gradientUnits="userSpaceOnUse">
                        <stop offset="0" stop-color="#009CFF" />
                        <stop offset="1" stop-color="#6257FF" />
                    </lineargradient>
                </defs>
            </svg>
        </div>

        <!-- Login form -->
        <form id="loginForm" class="login-form">
            <div class="form-group">
                <label for="username" class="form-label no-select">Username</label>
                <input type="text" id="username" class="form-input" placeholder="Enter your username">
                <svg class="input-icon username" viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <circle cx="12" cy="8" r="4"/>
                    <path d="M5.33788 17.3206C5.99897 14.5269 8.77173 13 11.6426 13H12.3574C15.2283 13 18.001 14.5269 18.6621 17.3206C18.79 17.8611 18.8917 18.4268 18.9489 19.0016C19.0036 19.5512 18.5523 20 18 20H6C5.44772 20 4.99642 19.5512 5.0511 19.0016C5.1083 18.4268 5.20997 17.8611 5.33788 17.3206Z"/>
                </svg>
            </div>
            <div class="form-group">
                <label for="password" class="form-label no-select">Password</label>
                <input type="password" id="password" class="form-input" placeholder="Enter your password">
                <svg class="input-icon password" viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <path fill-rule="evenodd" d="M12 2C9.238 2 7 4.238 7 7v3h-.4c-.88 0-1.6.72-1.6 1.6v7C5 19.92 6.08 21 7.4 21h9.2c1.32 0 2.4-1.08 2.4-2.4v-7c0-.88-.72-1.6-1.6-1.6H17V7c0-2.762-2.238-5-5-5Zm3 8V7c0-1.658-1.342-3-3-3S9 5.342 9 7v3h6Z"/>
                </svg>
            </div>

            <button type="submit" class="login-button no-select" id="loginButton">Log In</button>

            <div class="loader-container" id="loader-container">
                <div class="loader-bar" id="loader-bar"></div>
            </div>
        </form>

        <!-- Card footer -->
        <div class="card-footer no-select">
            PrettyOTA - Administrator page
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification" role="alert">
        <div class="notification-main-area">
            <div class="notification-icon-area">
                <svg viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="10" stroke="#e57373" stroke-width="2" fill="none"/>
                    <rect x="11" y="6.5" width="2" height="7" rx="1" fill="#e57373"/>
                    <circle cx="12" cy="16.5" r="1.35" fill="#e57373"/>
                </svg>
            </div>
            <div class="notification-content">
                <span id="notificationTitle" class="notification-title"></span>
                <span id="notificationMessage" class="notification-message"></span>
            </div>
        </div>
        <div class="notification-separator"></div>
        <button id="notificationCloseButton" class="notification-ok-button no-select">OK</button>
    </div>
</body>
</html>
